/******************************************************************************
 * This file was generated by langium-cli 3.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/
import { AbstractAstReflection } from 'langium';
export const OmlTerminals = {
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
    WS: /\s+/,
    BOOLEAN: /(false|true)/,
    DOUBLE: /((\+|-)?((([0-9])+(\.([0-9])*)?)|(\.([0-9])+))(e|E)(\+|-)?([0-9])+)/,
    DECIMAL: /(((\+|-)?(([0-9])+(\.([0-9])*)))|(\.([0-9])+))/,
    INTEGER: /((\+|-)([0-9])+)/,
    UNSIGNED_INTEGER: /([0-9])+/,
    STRING: /(((("""([\s\S]*?"""))|('''([\s\S]*?''')))|('([\s\S]*?')))|("([\s\S]*?")))/,
    NAMESPACE: /<[^# ]*[#/]>/,
    IRI: /<[^ ]*>/,
    QNAME: /(((((([a-zA-Z])|([0-9]))|([-_.~%]))(((([a-zA-Z])|([0-9]))|([-_.~%]))|\$)*)):((((([a-zA-Z])|([0-9]))|([-_.~%]))(((([a-zA-Z])|([0-9]))|([-_.~%]))|\$)*)))/,
    ID: /(\^?((((([a-zA-Z])|([0-9]))|([-_.~%]))(((([a-zA-Z])|([0-9]))|([-_.~%]))|\$)*)))/,
};
export const AnonymousInstance = 'AnonymousInstance';
export function isAnonymousInstance(item) {
    return reflection.isInstance(item, AnonymousInstance);
}
export const Assertion = 'Assertion';
export function isAssertion(item) {
    return reflection.isInstance(item, Assertion);
}
export const Axiom = 'Axiom';
export function isAxiom(item) {
    return reflection.isInstance(item, Axiom);
}
export const BinaryPredicate = 'BinaryPredicate';
export function isBinaryPredicate(item) {
    return reflection.isInstance(item, BinaryPredicate);
}
export function isBoolean(item) {
    return typeof item === 'boolean';
}
export function isCardinalityRestrictionKind(item) {
    return item === 'exactly' || item === 'min' || item === 'max';
}
export function isCrossRef(item) {
    return (typeof item === 'string' && (/(((((([a-zA-Z])|([0-9]))|([-_.~%]))(((([a-zA-Z])|([0-9]))|([-_.~%]))|\$)*)):((((([a-zA-Z])|([0-9]))|([-_.~%]))(((([a-zA-Z])|([0-9]))|([-_.~%]))|\$)*)))/.test(item) || /<[^ ]*>/.test(item)));
}
export function isDecimal(item) {
    return typeof item === 'number';
}
export const DescriptionBox = 'DescriptionBox';
export function isDescriptionBox(item) {
    return reflection.isInstance(item, DescriptionBox);
}
export const DescriptionMember = 'DescriptionMember';
export function isDescriptionMember(item) {
    return reflection.isInstance(item, DescriptionMember);
}
export const DescriptionStatement = 'DescriptionStatement';
export function isDescriptionStatement(item) {
    return reflection.isInstance(item, DescriptionStatement);
}
export function isDouble(item) {
    return typeof item === 'number';
}
export const Element = 'Element';
export function isElement(item) {
    return reflection.isInstance(item, Element);
}
export const Entity = 'Entity';
export function isEntity(item) {
    return reflection.isInstance(item, Entity);
}
export const IdentifiedElement = 'IdentifiedElement';
export function isIdentifiedElement(item) {
    return reflection.isInstance(item, IdentifiedElement);
}
export function isImportKind(item) {
    return item === 'extends' || item === 'uses' || item === 'includes';
}
export const Instance = 'Instance';
export function isInstance(item) {
    return reflection.isInstance(item, Instance);
}
export function isInteger(item) {
    return typeof item === 'number';
}
export const Literal = 'Literal';
export function isLiteral(item) {
    return reflection.isInstance(item, Literal);
}
export const Member = 'Member';
export function isMember(item) {
    return reflection.isInstance(item, Member);
}
export const NamedInstance = 'NamedInstance';
export function isNamedInstance(item) {
    return reflection.isInstance(item, NamedInstance);
}
export const Ontology = 'Ontology';
export function isOntology(item) {
    return reflection.isInstance(item, Ontology);
}
export const Predicate = 'Predicate';
export function isPredicate(item) {
    return reflection.isInstance(item, Predicate);
}
export const Property = 'Property';
export function isProperty(item) {
    return reflection.isInstance(item, Property);
}
export const PropertyRestrictionAxiom = 'PropertyRestrictionAxiom';
export function isPropertyRestrictionAxiom(item) {
    return reflection.isInstance(item, PropertyRestrictionAxiom);
}
export function isRangeRestrictionKind(item) {
    return item === 'all' || item === 'some';
}
export function isRef(item) {
    return (typeof item === 'string' && (/(((((([a-zA-Z])|([0-9]))|([-_.~%]))(((([a-zA-Z])|([0-9]))|([-_.~%]))|\$)*)):((((([a-zA-Z])|([0-9]))|([-_.~%]))(((([a-zA-Z])|([0-9]))|([-_.~%]))|\$)*)))/.test(item) || /(\^?((((([a-zA-Z])|([0-9]))|([-_.~%]))(((([a-zA-Z])|([0-9]))|([-_.~%]))|\$)*)))/.test(item) || /<[^ ]*>/.test(item)));
}
export const Relation = 'Relation';
export function isRelation(item) {
    return reflection.isInstance(item, Relation);
}
export const RelationBase = 'RelationBase';
export function isRelationBase(item) {
    return reflection.isInstance(item, RelationBase);
}
export const SemanticProperty = 'SemanticProperty';
export function isSemanticProperty(item) {
    return reflection.isInstance(item, SemanticProperty);
}
export const SpecializableProperty = 'SpecializableProperty';
export function isSpecializableProperty(item) {
    return reflection.isInstance(item, SpecializableProperty);
}
export const SpecializableTerm = 'SpecializableTerm';
export function isSpecializableTerm(item) {
    return reflection.isInstance(item, SpecializableTerm);
}
export const Statement = 'Statement';
export function isStatement(item) {
    return reflection.isInstance(item, Statement);
}
export const Term = 'Term';
export function isTerm(item) {
    return reflection.isInstance(item, Term);
}
export const Type = 'Type';
export function isType(item) {
    return reflection.isInstance(item, Type);
}
export const UnaryPredicate = 'UnaryPredicate';
export function isUnaryPredicate(item) {
    return reflection.isInstance(item, UnaryPredicate);
}
export function isUnsignedInteger(item) {
    return typeof item === 'number';
}
export const VocabularyBox = 'VocabularyBox';
export function isVocabularyBox(item) {
    return reflection.isInstance(item, VocabularyBox);
}
export const VocabularyMember = 'VocabularyMember';
export function isVocabularyMember(item) {
    return reflection.isInstance(item, VocabularyMember);
}
export const VocabularyStatement = 'VocabularyStatement';
export function isVocabularyStatement(item) {
    return reflection.isInstance(item, VocabularyStatement);
}
export const Annotation = 'Annotation';
export function isAnnotation(item) {
    return reflection.isInstance(item, Annotation);
}
export const AnnotationProperty = 'AnnotationProperty';
export function isAnnotationProperty(item) {
    return reflection.isInstance(item, AnnotationProperty);
}
export const AnonymousConceptInstance = 'AnonymousConceptInstance';
export function isAnonymousConceptInstance(item) {
    return reflection.isInstance(item, AnonymousConceptInstance);
}
export const AnonymousRelationInstance = 'AnonymousRelationInstance';
export function isAnonymousRelationInstance(item) {
    return reflection.isInstance(item, AnonymousRelationInstance);
}
export const Argument = 'Argument';
export function isArgument(item) {
    return reflection.isInstance(item, Argument);
}
export const Aspect = 'Aspect';
export function isAspect(item) {
    return reflection.isInstance(item, Aspect);
}
export const BooleanLiteral = 'BooleanLiteral';
export function isBooleanLiteral(item) {
    return reflection.isInstance(item, BooleanLiteral);
}
export const BuiltIn = 'BuiltIn';
export function isBuiltIn(item) {
    return reflection.isInstance(item, BuiltIn);
}
export const BuiltInPredicate = 'BuiltInPredicate';
export function isBuiltInPredicate(item) {
    return reflection.isInstance(item, BuiltInPredicate);
}
export const Concept = 'Concept';
export function isConcept(item) {
    return reflection.isInstance(item, Concept);
}
export const ConceptInstance = 'ConceptInstance';
export function isConceptInstance(item) {
    return reflection.isInstance(item, ConceptInstance);
}
export const DecimalLiteral = 'DecimalLiteral';
export function isDecimalLiteral(item) {
    return reflection.isInstance(item, DecimalLiteral);
}
export const Description = 'Description';
export function isDescription(item) {
    return reflection.isInstance(item, Description);
}
export const DescriptionBundle = 'DescriptionBundle';
export function isDescriptionBundle(item) {
    return reflection.isInstance(item, DescriptionBundle);
}
export const DifferentFromPredicate = 'DifferentFromPredicate';
export function isDifferentFromPredicate(item) {
    return reflection.isInstance(item, DifferentFromPredicate);
}
export const DoubleLiteral = 'DoubleLiteral';
export function isDoubleLiteral(item) {
    return reflection.isInstance(item, DoubleLiteral);
}
export const EntityEquivalenceAxiom = 'EntityEquivalenceAxiom';
export function isEntityEquivalenceAxiom(item) {
    return reflection.isInstance(item, EntityEquivalenceAxiom);
}
export const ForwardRelation = 'ForwardRelation';
export function isForwardRelation(item) {
    return reflection.isInstance(item, ForwardRelation);
}
export const Import = 'Import';
export function isImport(item) {
    return reflection.isInstance(item, Import);
}
export const InstanceEnumerationAxiom = 'InstanceEnumerationAxiom';
export function isInstanceEnumerationAxiom(item) {
    return reflection.isInstance(item, InstanceEnumerationAxiom);
}
export const IntegerLiteral = 'IntegerLiteral';
export function isIntegerLiteral(item) {
    return reflection.isInstance(item, IntegerLiteral);
}
export const KeyAxiom = 'KeyAxiom';
export function isKeyAxiom(item) {
    return reflection.isInstance(item, KeyAxiom);
}
export const LiteralEnumerationAxiom = 'LiteralEnumerationAxiom';
export function isLiteralEnumerationAxiom(item) {
    return reflection.isInstance(item, LiteralEnumerationAxiom);
}
export const PropertyCardinalityRestrictionAxiom = 'PropertyCardinalityRestrictionAxiom';
export function isPropertyCardinalityRestrictionAxiom(item) {
    return reflection.isInstance(item, PropertyCardinalityRestrictionAxiom);
}
export const PropertyEquivalenceAxiom = 'PropertyEquivalenceAxiom';
export function isPropertyEquivalenceAxiom(item) {
    return reflection.isInstance(item, PropertyEquivalenceAxiom);
}
export const PropertyPredicate = 'PropertyPredicate';
export function isPropertyPredicate(item) {
    return reflection.isInstance(item, PropertyPredicate);
}
export const PropertyRangeRestrictionAxiom = 'PropertyRangeRestrictionAxiom';
export function isPropertyRangeRestrictionAxiom(item) {
    return reflection.isInstance(item, PropertyRangeRestrictionAxiom);
}
export const PropertySelfRestrictionAxiom = 'PropertySelfRestrictionAxiom';
export function isPropertySelfRestrictionAxiom(item) {
    return reflection.isInstance(item, PropertySelfRestrictionAxiom);
}
export const PropertyValueAssertion = 'PropertyValueAssertion';
export function isPropertyValueAssertion(item) {
    return reflection.isInstance(item, PropertyValueAssertion);
}
export const PropertyValueRestrictionAxiom = 'PropertyValueRestrictionAxiom';
export function isPropertyValueRestrictionAxiom(item) {
    return reflection.isInstance(item, PropertyValueRestrictionAxiom);
}
export const QuotedLiteral = 'QuotedLiteral';
export function isQuotedLiteral(item) {
    return reflection.isInstance(item, QuotedLiteral);
}
export const RelationEntity = 'RelationEntity';
export function isRelationEntity(item) {
    return reflection.isInstance(item, RelationEntity);
}
export const RelationEntityPredicate = 'RelationEntityPredicate';
export function isRelationEntityPredicate(item) {
    return reflection.isInstance(item, RelationEntityPredicate);
}
export const RelationInstance = 'RelationInstance';
export function isRelationInstance(item) {
    return reflection.isInstance(item, RelationInstance);
}
export const ReverseRelation = 'ReverseRelation';
export function isReverseRelation(item) {
    return reflection.isInstance(item, ReverseRelation);
}
export const Rule = 'Rule';
export function isRule(item) {
    return reflection.isInstance(item, Rule);
}
export const SameAsPredicate = 'SameAsPredicate';
export function isSameAsPredicate(item) {
    return reflection.isInstance(item, SameAsPredicate);
}
export const Scalar = 'Scalar';
export function isScalar(item) {
    return reflection.isInstance(item, Scalar);
}
export const ScalarEquivalenceAxiom = 'ScalarEquivalenceAxiom';
export function isScalarEquivalenceAxiom(item) {
    return reflection.isInstance(item, ScalarEquivalenceAxiom);
}
export const ScalarProperty = 'ScalarProperty';
export function isScalarProperty(item) {
    return reflection.isInstance(item, ScalarProperty);
}
export const SpecializationAxiom = 'SpecializationAxiom';
export function isSpecializationAxiom(item) {
    return reflection.isInstance(item, SpecializationAxiom);
}
export const TypeAssertion = 'TypeAssertion';
export function isTypeAssertion(item) {
    return reflection.isInstance(item, TypeAssertion);
}
export const TypePredicate = 'TypePredicate';
export function isTypePredicate(item) {
    return reflection.isInstance(item, TypePredicate);
}
export const UnreifiedRelation = 'UnreifiedRelation';
export function isUnreifiedRelation(item) {
    return reflection.isInstance(item, UnreifiedRelation);
}
export const Vocabulary = 'Vocabulary';
export function isVocabulary(item) {
    return reflection.isInstance(item, Vocabulary);
}
export const VocabularyBundle = 'VocabularyBundle';
export function isVocabularyBundle(item) {
    return reflection.isInstance(item, VocabularyBundle);
}
export class OmlAstReflection extends AbstractAstReflection {
    getAllTypes() {
        return [Annotation, AnnotationProperty, AnonymousConceptInstance, AnonymousInstance, AnonymousRelationInstance, Argument, Aspect, Assertion, Axiom, BinaryPredicate, BooleanLiteral, BuiltIn, BuiltInPredicate, Concept, ConceptInstance, DecimalLiteral, Description, DescriptionBox, DescriptionBundle, DescriptionMember, DescriptionStatement, DifferentFromPredicate, DoubleLiteral, Element, Entity, EntityEquivalenceAxiom, ForwardRelation, IdentifiedElement, Import, Instance, InstanceEnumerationAxiom, IntegerLiteral, KeyAxiom, Literal, LiteralEnumerationAxiom, Member, NamedInstance, Ontology, Predicate, Property, PropertyCardinalityRestrictionAxiom, PropertyEquivalenceAxiom, PropertyPredicate, PropertyRangeRestrictionAxiom, PropertyRestrictionAxiom, PropertySelfRestrictionAxiom, PropertyValueAssertion, PropertyValueRestrictionAxiom, QuotedLiteral, Relation, RelationBase, RelationEntity, RelationEntityPredicate, RelationInstance, ReverseRelation, Rule, SameAsPredicate, Scalar, ScalarEquivalenceAxiom, ScalarProperty, SemanticProperty, SpecializableProperty, SpecializableTerm, SpecializationAxiom, Statement, Term, Type, TypeAssertion, TypePredicate, UnaryPredicate, UnreifiedRelation, Vocabulary, VocabularyBox, VocabularyBundle, VocabularyMember, VocabularyStatement];
    }
    computeIsSubtype(subtype, supertype) {
        switch (subtype) {
            case Annotation:
            case Argument:
            case Assertion:
            case Axiom:
            case IdentifiedElement:
            case Import:
            case Instance:
            case Literal:
            case Predicate: {
                return this.isSubtype(Element, supertype);
            }
            case AnnotationProperty: {
                return this.isSubtype(SpecializableProperty, supertype);
            }
            case AnonymousConceptInstance:
            case AnonymousRelationInstance: {
                return this.isSubtype(AnonymousInstance, supertype);
            }
            case AnonymousInstance: {
                return this.isSubtype(Instance, supertype);
            }
            case Aspect:
            case Concept: {
                return this.isSubtype(Entity, supertype);
            }
            case BinaryPredicate:
            case BuiltInPredicate:
            case UnaryPredicate: {
                return this.isSubtype(Predicate, supertype);
            }
            case BooleanLiteral:
            case DecimalLiteral:
            case DoubleLiteral:
            case IntegerLiteral:
            case QuotedLiteral: {
                return this.isSubtype(Literal, supertype);
            }
            case BuiltIn:
            case Rule: {
                return this.isSubtype(VocabularyStatement, supertype);
            }
            case ConceptInstance:
            case RelationInstance: {
                return this.isSubtype(NamedInstance, supertype);
            }
            case Description:
            case DescriptionBundle: {
                return this.isSubtype(DescriptionBox, supertype);
            }
            case DescriptionBox:
            case VocabularyBox: {
                return this.isSubtype(Ontology, supertype);
            }
            case DescriptionMember:
            case Statement:
            case VocabularyMember: {
                return this.isSubtype(Member, supertype);
            }
            case DescriptionStatement: {
                return this.isSubtype(DescriptionMember, supertype) || this.isSubtype(Statement, supertype);
            }
            case DifferentFromPredicate:
            case PropertyPredicate:
            case SameAsPredicate: {
                return this.isSubtype(BinaryPredicate, supertype);
            }
            case Entity:
            case Scalar: {
                return this.isSubtype(Type, supertype);
            }
            case EntityEquivalenceAxiom:
            case InstanceEnumerationAxiom:
            case KeyAxiom:
            case LiteralEnumerationAxiom:
            case PropertyEquivalenceAxiom:
            case PropertyRestrictionAxiom:
            case ScalarEquivalenceAxiom:
            case SpecializationAxiom: {
                return this.isSubtype(Axiom, supertype);
            }
            case ForwardRelation:
            case ReverseRelation: {
                return this.isSubtype(Relation, supertype);
            }
            case Member:
            case Ontology: {
                return this.isSubtype(IdentifiedElement, supertype);
            }
            case NamedInstance: {
                return this.isSubtype(DescriptionStatement, supertype) || this.isSubtype(Instance, supertype);
            }
            case Property:
            case RelationBase: {
                return this.isSubtype(Term, supertype);
            }
            case PropertyCardinalityRestrictionAxiom:
            case PropertyRangeRestrictionAxiom:
            case PropertySelfRestrictionAxiom:
            case PropertyValueRestrictionAxiom: {
                return this.isSubtype(PropertyRestrictionAxiom, supertype);
            }
            case PropertyValueAssertion:
            case TypeAssertion: {
                return this.isSubtype(Assertion, supertype);
            }
            case Relation: {
                return this.isSubtype(SemanticProperty, supertype);
            }
            case RelationEntity: {
                return this.isSubtype(Entity, supertype) || this.isSubtype(RelationBase, supertype);
            }
            case RelationEntityPredicate:
            case TypePredicate: {
                return this.isSubtype(UnaryPredicate, supertype);
            }
            case ScalarProperty: {
                return this.isSubtype(SemanticProperty, supertype) || this.isSubtype(SpecializableProperty, supertype);
            }
            case SemanticProperty: {
                return this.isSubtype(Property, supertype);
            }
            case SpecializableProperty: {
                return this.isSubtype(Property, supertype) || this.isSubtype(SpecializableTerm, supertype);
            }
            case SpecializableTerm: {
                return this.isSubtype(Term, supertype) || this.isSubtype(VocabularyStatement, supertype);
            }
            case Term: {
                return this.isSubtype(VocabularyMember, supertype);
            }
            case Type: {
                return this.isSubtype(SpecializableTerm, supertype);
            }
            case UnreifiedRelation: {
                return this.isSubtype(Relation, supertype) || this.isSubtype(RelationBase, supertype) || this.isSubtype(SpecializableProperty, supertype);
            }
            case Vocabulary:
            case VocabularyBundle: {
                return this.isSubtype(VocabularyBox, supertype);
            }
            case VocabularyStatement: {
                return this.isSubtype(Statement, supertype) || this.isSubtype(VocabularyMember, supertype);
            }
            default: {
                return false;
            }
        }
    }
    getReferenceType(refInfo) {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Annotation:property':
            case 'AnnotationProperty:ref': {
                return AnnotationProperty;
            }
            case 'Annotation:referencedValues': {
                return Member;
            }
            case 'AnonymousConceptInstance:type':
            case 'Concept:ref': {
                return Concept;
            }
            case 'AnonymousRelationInstance:target':
            case 'Argument:instance':
            case 'PropertyValueAssertion:referencedValues':
            case 'PropertyValueRestrictionAxiom:referencedValue':
            case 'RelationInstance:sources':
            case 'RelationInstance:targets': {
                return NamedInstance;
            }
            case 'Aspect:ref': {
                return Aspect;
            }
            case 'BuiltIn:ref':
            case 'BuiltInPredicate:builtIn': {
                return BuiltIn;
            }
            case 'ConceptInstance:ref':
            case 'InstanceEnumerationAxiom:instances': {
                return ConceptInstance;
            }
            case 'EntityEquivalenceAxiom:superEntities':
            case 'RelationEntity:sources':
            case 'RelationEntity:targets':
            case 'ScalarProperty:domains':
            case 'TypeAssertion:type':
            case 'UnreifiedRelation:sources':
            case 'UnreifiedRelation:targets': {
                return Entity;
            }
            case 'Import:imported': {
                return Ontology;
            }
            case 'KeyAxiom:properties':
            case 'PropertyEquivalenceAxiom:superProperty':
            case 'PropertyPredicate:property': {
                return Property;
            }
            case 'PropertyCardinalityRestrictionAxiom:property':
            case 'PropertyRangeRestrictionAxiom:property':
            case 'PropertySelfRestrictionAxiom:property':
            case 'PropertyValueAssertion:property':
            case 'PropertyValueRestrictionAxiom:property': {
                return SemanticProperty;
            }
            case 'PropertyCardinalityRestrictionAxiom:range':
            case 'PropertyRangeRestrictionAxiom:range':
            case 'TypePredicate:type': {
                return Type;
            }
            case 'QuotedLiteral:type':
            case 'Scalar:ref':
            case 'ScalarEquivalenceAxiom:superScalar':
            case 'ScalarProperty:ranges': {
                return Scalar;
            }
            case 'RelationEntity:ref':
            case 'RelationEntityPredicate:type': {
                return RelationEntity;
            }
            case 'RelationInstance:ref': {
                return RelationInstance;
            }
            case 'Rule:ref': {
                return Rule;
            }
            case 'ScalarProperty:ref': {
                return ScalarProperty;
            }
            case 'SpecializationAxiom:superTerm': {
                return Term;
            }
            case 'UnreifiedRelation:ref': {
                return Relation;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
    getTypeMetaData(type) {
        switch (type) {
            case Annotation: {
                return {
                    name: Annotation,
                    properties: [
                        { name: 'literalValues', defaultValue: [] },
                        { name: 'property' },
                        { name: 'referencedValues', defaultValue: [] }
                    ]
                };
            }
            case AnnotationProperty: {
                return {
                    name: AnnotationProperty,
                    properties: [
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedEquivalences', defaultValue: [] },
                        { name: 'ownedSpecializations', defaultValue: [] },
                        { name: 'ref' }
                    ]
                };
            }
            case AnonymousConceptInstance: {
                return {
                    name: AnonymousConceptInstance,
                    properties: [
                        { name: 'ownedPropertyValues', defaultValue: [] },
                        { name: 'type' }
                    ]
                };
            }
            case AnonymousRelationInstance: {
                return {
                    name: AnonymousRelationInstance,
                    properties: [
                        { name: 'ownedPropertyValues', defaultValue: [] },
                        { name: 'target' }
                    ]
                };
            }
            case Argument: {
                return {
                    name: Argument,
                    properties: [
                        { name: 'instance' },
                        { name: 'literal' },
                        { name: 'variable' }
                    ]
                };
            }
            case Aspect: {
                return {
                    name: Aspect,
                    properties: [
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedEquivalences', defaultValue: [] },
                        { name: 'ownedKeys', defaultValue: [] },
                        { name: 'ownedPropertyRestrictions', defaultValue: [] },
                        { name: 'ownedSpecializations', defaultValue: [] },
                        { name: 'ref' }
                    ]
                };
            }
            case BooleanLiteral: {
                return {
                    name: BooleanLiteral,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case BuiltIn: {
                return {
                    name: BuiltIn,
                    properties: [
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ref' }
                    ]
                };
            }
            case BuiltInPredicate: {
                return {
                    name: BuiltInPredicate,
                    properties: [
                        { name: 'arguments', defaultValue: [] },
                        { name: 'builtIn' }
                    ]
                };
            }
            case Concept: {
                return {
                    name: Concept,
                    properties: [
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedEnumeration' },
                        { name: 'ownedEquivalences', defaultValue: [] },
                        { name: 'ownedKeys', defaultValue: [] },
                        { name: 'ownedPropertyRestrictions', defaultValue: [] },
                        { name: 'ownedSpecializations', defaultValue: [] },
                        { name: 'ref' }
                    ]
                };
            }
            case ConceptInstance: {
                return {
                    name: ConceptInstance,
                    properties: [
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedPropertyValues', defaultValue: [] },
                        { name: 'ownedTypes', defaultValue: [] },
                        { name: 'ref' }
                    ]
                };
            }
            case DecimalLiteral: {
                return {
                    name: DecimalLiteral,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case Description: {
                return {
                    name: Description,
                    properties: [
                        { name: 'namespace' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedImports', defaultValue: [] },
                        { name: 'ownedStatements', defaultValue: [] },
                        { name: 'prefix' }
                    ]
                };
            }
            case DescriptionBundle: {
                return {
                    name: DescriptionBundle,
                    properties: [
                        { name: 'namespace' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedImports', defaultValue: [] },
                        { name: 'prefix' }
                    ]
                };
            }
            case DifferentFromPredicate: {
                return {
                    name: DifferentFromPredicate,
                    properties: [
                        { name: 'argument1' },
                        { name: 'argument2' }
                    ]
                };
            }
            case DoubleLiteral: {
                return {
                    name: DoubleLiteral,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case EntityEquivalenceAxiom: {
                return {
                    name: EntityEquivalenceAxiom,
                    properties: [
                        { name: 'ownedPropertyRestrictions', defaultValue: [] },
                        { name: 'superEntities', defaultValue: [] }
                    ]
                };
            }
            case ForwardRelation: {
                return {
                    name: ForwardRelation,
                    properties: [
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] }
                    ]
                };
            }
            case Import: {
                return {
                    name: Import,
                    properties: [
                        { name: 'imported' },
                        { name: 'kind' },
                        { name: 'prefix' }
                    ]
                };
            }
            case InstanceEnumerationAxiom: {
                return {
                    name: InstanceEnumerationAxiom,
                    properties: [
                        { name: 'instances', defaultValue: [] }
                    ]
                };
            }
            case IntegerLiteral: {
                return {
                    name: IntegerLiteral,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case KeyAxiom: {
                return {
                    name: KeyAxiom,
                    properties: [
                        { name: 'properties', defaultValue: [] }
                    ]
                };
            }
            case LiteralEnumerationAxiom: {
                return {
                    name: LiteralEnumerationAxiom,
                    properties: [
                        { name: 'literals', defaultValue: [] }
                    ]
                };
            }
            case PropertyCardinalityRestrictionAxiom: {
                return {
                    name: PropertyCardinalityRestrictionAxiom,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'kind' },
                        { name: 'property' },
                        { name: 'range' }
                    ]
                };
            }
            case PropertyEquivalenceAxiom: {
                return {
                    name: PropertyEquivalenceAxiom,
                    properties: [
                        { name: 'superProperty' }
                    ]
                };
            }
            case PropertyPredicate: {
                return {
                    name: PropertyPredicate,
                    properties: [
                        { name: 'argument1' },
                        { name: 'argument2' },
                        { name: 'property' }
                    ]
                };
            }
            case PropertyRangeRestrictionAxiom: {
                return {
                    name: PropertyRangeRestrictionAxiom,
                    properties: [
                        { name: 'kind' },
                        { name: 'property' },
                        { name: 'range' }
                    ]
                };
            }
            case PropertySelfRestrictionAxiom: {
                return {
                    name: PropertySelfRestrictionAxiom,
                    properties: [
                        { name: 'property' }
                    ]
                };
            }
            case PropertyValueAssertion: {
                return {
                    name: PropertyValueAssertion,
                    properties: [
                        { name: 'containedValues', defaultValue: [] },
                        { name: 'literalValues', defaultValue: [] },
                        { name: 'property' },
                        { name: 'referencedValues', defaultValue: [] }
                    ]
                };
            }
            case PropertyValueRestrictionAxiom: {
                return {
                    name: PropertyValueRestrictionAxiom,
                    properties: [
                        { name: 'containedValue' },
                        { name: 'literalValue' },
                        { name: 'property' },
                        { name: 'referencedValue' }
                    ]
                };
            }
            case QuotedLiteral: {
                return {
                    name: QuotedLiteral,
                    properties: [
                        { name: 'langTag' },
                        { name: 'type' },
                        { name: 'value' }
                    ]
                };
            }
            case RelationEntity: {
                return {
                    name: RelationEntity,
                    properties: [
                        { name: 'asymmetric', defaultValue: false },
                        { name: 'forwardRelation' },
                        { name: 'functional', defaultValue: false },
                        { name: 'inverseFunctional', defaultValue: false },
                        { name: 'irreflexive', defaultValue: false },
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedEquivalences', defaultValue: [] },
                        { name: 'ownedKeys', defaultValue: [] },
                        { name: 'ownedPropertyRestrictions', defaultValue: [] },
                        { name: 'ownedSpecializations', defaultValue: [] },
                        { name: 'ref' },
                        { name: 'reflexive', defaultValue: false },
                        { name: 'reverseRelation' },
                        { name: 'sources', defaultValue: [] },
                        { name: 'symmetric', defaultValue: false },
                        { name: 'targets', defaultValue: [] },
                        { name: 'transitive', defaultValue: false }
                    ]
                };
            }
            case RelationEntityPredicate: {
                return {
                    name: RelationEntityPredicate,
                    properties: [
                        { name: 'argument' },
                        { name: 'argument1' },
                        { name: 'argument2' },
                        { name: 'type' }
                    ]
                };
            }
            case RelationInstance: {
                return {
                    name: RelationInstance,
                    properties: [
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedPropertyValues', defaultValue: [] },
                        { name: 'ownedTypes', defaultValue: [] },
                        { name: 'ref' },
                        { name: 'sources', defaultValue: [] },
                        { name: 'targets', defaultValue: [] }
                    ]
                };
            }
            case ReverseRelation: {
                return {
                    name: ReverseRelation,
                    properties: [
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] }
                    ]
                };
            }
            case Rule: {
                return {
                    name: Rule,
                    properties: [
                        { name: 'antecedent', defaultValue: [] },
                        { name: 'consequent', defaultValue: [] },
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ref' }
                    ]
                };
            }
            case SameAsPredicate: {
                return {
                    name: SameAsPredicate,
                    properties: [
                        { name: 'argument1' },
                        { name: 'argument2' }
                    ]
                };
            }
            case Scalar: {
                return {
                    name: Scalar,
                    properties: [
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedEnumeration' },
                        { name: 'ownedEquivalences', defaultValue: [] },
                        { name: 'ownedSpecializations', defaultValue: [] },
                        { name: 'ref' }
                    ]
                };
            }
            case ScalarEquivalenceAxiom: {
                return {
                    name: ScalarEquivalenceAxiom,
                    properties: [
                        { name: 'language', defaultValue: [] },
                        { name: 'length', defaultValue: [] },
                        { name: 'maxExclusive', defaultValue: [] },
                        { name: 'maxInclusive', defaultValue: [] },
                        { name: 'maxLength', defaultValue: [] },
                        { name: 'minExclusive', defaultValue: [] },
                        { name: 'minInclusive', defaultValue: [] },
                        { name: 'minLength', defaultValue: [] },
                        { name: 'pattern', defaultValue: [] },
                        { name: 'superScalar' }
                    ]
                };
            }
            case ScalarProperty: {
                return {
                    name: ScalarProperty,
                    properties: [
                        { name: 'domains', defaultValue: [] },
                        { name: 'functional', defaultValue: false },
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedEquivalences', defaultValue: [] },
                        { name: 'ownedSpecializations', defaultValue: [] },
                        { name: 'ranges', defaultValue: [] },
                        { name: 'ref' }
                    ]
                };
            }
            case SpecializationAxiom: {
                return {
                    name: SpecializationAxiom,
                    properties: [
                        { name: 'superTerm' }
                    ]
                };
            }
            case TypeAssertion: {
                return {
                    name: TypeAssertion,
                    properties: [
                        { name: 'type' }
                    ]
                };
            }
            case TypePredicate: {
                return {
                    name: TypePredicate,
                    properties: [
                        { name: 'argument' },
                        { name: 'type' }
                    ]
                };
            }
            case UnreifiedRelation: {
                return {
                    name: UnreifiedRelation,
                    properties: [
                        { name: 'asymmetric', defaultValue: false },
                        { name: 'functional', defaultValue: false },
                        { name: 'inverseFunctional', defaultValue: false },
                        { name: 'irreflexive', defaultValue: false },
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedEquivalences', defaultValue: [] },
                        { name: 'ownedSpecializations', defaultValue: [] },
                        { name: 'ref' },
                        { name: 'reflexive', defaultValue: false },
                        { name: 'reverseRelation' },
                        { name: 'sources', defaultValue: [] },
                        { name: 'symmetric', defaultValue: false },
                        { name: 'targets', defaultValue: [] },
                        { name: 'transitive', defaultValue: false }
                    ]
                };
            }
            case Vocabulary: {
                return {
                    name: Vocabulary,
                    properties: [
                        { name: 'namespace' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedImports', defaultValue: [] },
                        { name: 'ownedStatements', defaultValue: [] },
                        { name: 'prefix' }
                    ]
                };
            }
            case VocabularyBundle: {
                return {
                    name: VocabularyBundle,
                    properties: [
                        { name: 'namespace' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedImports', defaultValue: [] },
                        { name: 'prefix' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    properties: []
                };
            }
        }
    }
}
export const reflection = new OmlAstReflection();
//# sourceMappingURL=ast.js.map