/******************************************************************************
 * This file was generated by langium-cli 3.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import type { AstNode, Reference, ReferenceInfo, TypeMetaData } from 'langium';
import { AbstractAstReflection } from 'langium';

export const OmlTerminals = {
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
    WS: /\s+/,
    BOOLEAN: /(false|true)/,
    DOUBLE: /((\+|-)?((([0-9])+(\.([0-9])*)?)|(\.([0-9])+))(e|E)(\+|-)?([0-9])+)/,
    DECIMAL: /(((\+|-)?(([0-9])+(\.([0-9])*)))|(\.([0-9])+))/,
    INTEGER: /((\+|-)([0-9])+)/,
    UNSIGNED_INTEGER: /([0-9])+/,
    STRING: /(((("""([\s\S]*?"""))|('''([\s\S]*?''')))|('([\s\S]*?')))|("([\s\S]*?")))/,
    NAMESPACE: /<[^# ]*[#/]>/,
    IRI: /<[^ ]*>/,
    QNAME: /(((((([a-zA-Z])|([0-9]))|([-_.~%]))(((([a-zA-Z])|([0-9]))|([-_.~%]))|\$)*)):((((([a-zA-Z])|([0-9]))|([-_.~%]))(((([a-zA-Z])|([0-9]))|([-_.~%]))|\$)*)))/,
    ID: /(\^?((((([a-zA-Z])|([0-9]))|([-_.~%]))(((([a-zA-Z])|([0-9]))|([-_.~%]))|\$)*)))/,
};

export type OmlTerminalNames = keyof typeof OmlTerminals;

export type OmlKeywordNames = 
    | "$"
    | "&"
    | "("
    | ")"
    | ","
    | "->"
    | ":"
    | "<"
    | "="
    | "@"
    | "["
    | "]"
    | "^^"
    | "all"
    | "annotation"
    | "as"
    | "aspect"
    | "asymmetric"
    | "builtIn"
    | "builtin"
    | "bundle"
    | "concept"
    | "description"
    | "differentFrom"
    | "domain"
    | "entity"
    | "exactly"
    | "extends"
    | "forward"
    | "from"
    | "functional"
    | "includes"
    | "instance"
    | "inverse"
    | "irreflexive"
    | "key"
    | "language"
    | "length"
    | "max"
    | "maxExclusive"
    | "maxInclusive"
    | "maxLength"
    | "min"
    | "minExclusive"
    | "minInclusive"
    | "minLength"
    | "oneOf"
    | "pattern"
    | "property"
    | "range"
    | "ref"
    | "reflexive"
    | "relation"
    | "restricts"
    | "reverse"
    | "rule"
    | "sameAs"
    | "scalar"
    | "self"
    | "some"
    | "symmetric"
    | "to"
    | "transitive"
    | "uses"
    | "vocabulary"
    | "{"
    | "}";

export type OmlTokenNames = OmlTerminalNames | OmlKeywordNames;

export type AnonymousInstance = AnonymousConceptInstance | AnonymousRelationInstance;

export const AnonymousInstance = 'AnonymousInstance';

export function isAnonymousInstance(item: unknown): item is AnonymousInstance {
    return reflection.isInstance(item, AnonymousInstance);
}

export type Assertion = PropertyValueAssertion | TypeAssertion;

export const Assertion = 'Assertion';

export function isAssertion(item: unknown): item is Assertion {
    return reflection.isInstance(item, Assertion);
}

export type Axiom = EntityEquivalenceAxiom | InstanceEnumerationAxiom | KeyAxiom | LiteralEnumerationAxiom | PropertyEquivalenceAxiom | PropertyRestrictionAxiom | ScalarEquivalenceAxiom | SpecializationAxiom;

export const Axiom = 'Axiom';

export function isAxiom(item: unknown): item is Axiom {
    return reflection.isInstance(item, Axiom);
}

export type BinaryPredicate = DifferentFromPredicate | PropertyPredicate | SameAsPredicate;

export const BinaryPredicate = 'BinaryPredicate';

export function isBinaryPredicate(item: unknown): item is BinaryPredicate {
    return reflection.isInstance(item, BinaryPredicate);
}

export type Boolean = boolean;

export function isBoolean(item: unknown): item is Boolean {
    return typeof item === 'boolean';
}

export type CardinalityRestrictionKind = 'exactly' | 'max' | 'min';

export function isCardinalityRestrictionKind(item: unknown): item is CardinalityRestrictionKind {
    return item === 'exactly' || item === 'min' || item === 'max';
}

export type CrossRef = string;

export function isCrossRef(item: unknown): item is CrossRef {
    return (typeof item === 'string' && (/(((((([a-zA-Z])|([0-9]))|([-_.~%]))(((([a-zA-Z])|([0-9]))|([-_.~%]))|\$)*)):((((([a-zA-Z])|([0-9]))|([-_.~%]))(((([a-zA-Z])|([0-9]))|([-_.~%]))|\$)*)))/.test(item) || /<[^ ]*>/.test(item)));
}

export type Decimal = number;

export function isDecimal(item: unknown): item is Decimal {
    return typeof item === 'number';
}

export type DescriptionBox = Description | DescriptionBundle;

export const DescriptionBox = 'DescriptionBox';

export function isDescriptionBox(item: unknown): item is DescriptionBox {
    return reflection.isInstance(item, DescriptionBox);
}

export type DescriptionMember = DescriptionStatement;

export const DescriptionMember = 'DescriptionMember';

export function isDescriptionMember(item: unknown): item is DescriptionMember {
    return reflection.isInstance(item, DescriptionMember);
}

export type DescriptionStatement = NamedInstance;

export const DescriptionStatement = 'DescriptionStatement';

export function isDescriptionStatement(item: unknown): item is DescriptionStatement {
    return reflection.isInstance(item, DescriptionStatement);
}

export type Double = number;

export function isDouble(item: unknown): item is Double {
    return typeof item === 'number';
}

export type Element = Annotation | Argument | Assertion | Axiom | IdentifiedElement | Import | Instance | Literal | Predicate;

export const Element = 'Element';

export function isElement(item: unknown): item is Element {
    return reflection.isInstance(item, Element);
}

export type Entity = Aspect | Concept | RelationEntity;

export const Entity = 'Entity';

export function isEntity(item: unknown): item is Entity {
    return reflection.isInstance(item, Entity);
}

export type IdentifiedElement = Member | Ontology;

export const IdentifiedElement = 'IdentifiedElement';

export function isIdentifiedElement(item: unknown): item is IdentifiedElement {
    return reflection.isInstance(item, IdentifiedElement);
}

export type ImportKind = 'extends' | 'includes' | 'uses';

export function isImportKind(item: unknown): item is ImportKind {
    return item === 'extends' || item === 'uses' || item === 'includes';
}

export type Instance = AnonymousInstance | NamedInstance;

export const Instance = 'Instance';

export function isInstance(item: unknown): item is Instance {
    return reflection.isInstance(item, Instance);
}

export type Integer = number;

export function isInteger(item: unknown): item is Integer {
    return typeof item === 'number';
}

export type Literal = BooleanLiteral | DecimalLiteral | DoubleLiteral | IntegerLiteral | QuotedLiteral;

export const Literal = 'Literal';

export function isLiteral(item: unknown): item is Literal {
    return reflection.isInstance(item, Literal);
}

export type Member = DescriptionMember | Statement | VocabularyMember;

export const Member = 'Member';

export function isMember(item: unknown): item is Member {
    return reflection.isInstance(item, Member);
}

export type NamedInstance = ConceptInstance | RelationInstance;

export const NamedInstance = 'NamedInstance';

export function isNamedInstance(item: unknown): item is NamedInstance {
    return reflection.isInstance(item, NamedInstance);
}

export type Ontology = DescriptionBox | VocabularyBox;

export const Ontology = 'Ontology';

export function isOntology(item: unknown): item is Ontology {
    return reflection.isInstance(item, Ontology);
}

export type Predicate = BinaryPredicate | BuiltInPredicate | UnaryPredicate;

export const Predicate = 'Predicate';

export function isPredicate(item: unknown): item is Predicate {
    return reflection.isInstance(item, Predicate);
}

export type Property = SemanticProperty | SpecializableProperty;

export const Property = 'Property';

export function isProperty(item: unknown): item is Property {
    return reflection.isInstance(item, Property);
}

export type PropertyRestrictionAxiom = PropertyCardinalityRestrictionAxiom | PropertyRangeRestrictionAxiom | PropertySelfRestrictionAxiom | PropertyValueRestrictionAxiom;

export const PropertyRestrictionAxiom = 'PropertyRestrictionAxiom';

export function isPropertyRestrictionAxiom(item: unknown): item is PropertyRestrictionAxiom {
    return reflection.isInstance(item, PropertyRestrictionAxiom);
}

export type RangeRestrictionKind = 'all' | 'some';

export function isRangeRestrictionKind(item: unknown): item is RangeRestrictionKind {
    return item === 'all' || item === 'some';
}

export type Ref = string;

export function isRef(item: unknown): item is Ref {
    return (typeof item === 'string' && (/(((((([a-zA-Z])|([0-9]))|([-_.~%]))(((([a-zA-Z])|([0-9]))|([-_.~%]))|\$)*)):((((([a-zA-Z])|([0-9]))|([-_.~%]))(((([a-zA-Z])|([0-9]))|([-_.~%]))|\$)*)))/.test(item) || /(\^?((((([a-zA-Z])|([0-9]))|([-_.~%]))(((([a-zA-Z])|([0-9]))|([-_.~%]))|\$)*)))/.test(item) || /<[^ ]*>/.test(item)));
}

export type Relation = ForwardRelation | ReverseRelation | UnreifiedRelation;

export const Relation = 'Relation';

export function isRelation(item: unknown): item is Relation {
    return reflection.isInstance(item, Relation);
}

export type RelationBase = RelationEntity | UnreifiedRelation;

export const RelationBase = 'RelationBase';

export function isRelationBase(item: unknown): item is RelationBase {
    return reflection.isInstance(item, RelationBase);
}

export type SemanticProperty = Relation | ScalarProperty;

export const SemanticProperty = 'SemanticProperty';

export function isSemanticProperty(item: unknown): item is SemanticProperty {
    return reflection.isInstance(item, SemanticProperty);
}

export type SpecializableProperty = AnnotationProperty | ScalarProperty | UnreifiedRelation;

export const SpecializableProperty = 'SpecializableProperty';

export function isSpecializableProperty(item: unknown): item is SpecializableProperty {
    return reflection.isInstance(item, SpecializableProperty);
}

export type SpecializableTerm = SpecializableProperty | Type;

export const SpecializableTerm = 'SpecializableTerm';

export function isSpecializableTerm(item: unknown): item is SpecializableTerm {
    return reflection.isInstance(item, SpecializableTerm);
}

export type Statement = DescriptionStatement | VocabularyStatement;

export const Statement = 'Statement';

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement);
}

export type Term = Property | RelationBase | SpecializableTerm;

export const Term = 'Term';

export function isTerm(item: unknown): item is Term {
    return reflection.isInstance(item, Term);
}

export type Type = Entity | Scalar;

export const Type = 'Type';

export function isType(item: unknown): item is Type {
    return reflection.isInstance(item, Type);
}

export type UnaryPredicate = RelationEntityPredicate | TypePredicate;

export const UnaryPredicate = 'UnaryPredicate';

export function isUnaryPredicate(item: unknown): item is UnaryPredicate {
    return reflection.isInstance(item, UnaryPredicate);
}

export type UnsignedInteger = number;

export function isUnsignedInteger(item: unknown): item is UnsignedInteger {
    return typeof item === 'number';
}

export type VocabularyBox = Vocabulary | VocabularyBundle;

export const VocabularyBox = 'VocabularyBox';

export function isVocabularyBox(item: unknown): item is VocabularyBox {
    return reflection.isInstance(item, VocabularyBox);
}

export type VocabularyMember = Term | VocabularyStatement;

export const VocabularyMember = 'VocabularyMember';

export function isVocabularyMember(item: unknown): item is VocabularyMember {
    return reflection.isInstance(item, VocabularyMember);
}

export type VocabularyStatement = BuiltIn | Rule | SpecializableTerm;

export const VocabularyStatement = 'VocabularyStatement';

export function isVocabularyStatement(item: unknown): item is VocabularyStatement {
    return reflection.isInstance(item, VocabularyStatement);
}

export interface Annotation extends AstNode {
    readonly $container: AnnotationProperty | Aspect | BuiltIn | Concept | ConceptInstance | Description | DescriptionBundle | ForwardRelation | RelationEntity | RelationInstance | ReverseRelation | Rule | Scalar | ScalarProperty | UnreifiedRelation | Vocabulary | VocabularyBundle;
    readonly $type: 'Annotation';
    literalValues: Array<Literal>;
    property: Reference<AnnotationProperty>;
    referencedValues: Array<Reference<Member>>;
}

export const Annotation = 'Annotation';

export function isAnnotation(item: unknown): item is Annotation {
    return reflection.isInstance(item, Annotation);
}

export interface AnnotationProperty extends AstNode {
    readonly $container: Vocabulary;
    readonly $type: 'AnnotationProperty';
    name?: string;
    ownedAnnotations: Array<Annotation>;
    ownedEquivalences: Array<PropertyEquivalenceAxiom>;
    ownedSpecializations: Array<SpecializationAxiom>;
    ref?: Reference<AnnotationProperty>;
}

export const AnnotationProperty = 'AnnotationProperty';

export function isAnnotationProperty(item: unknown): item is AnnotationProperty {
    return reflection.isInstance(item, AnnotationProperty);
}

export interface AnonymousConceptInstance extends AstNode {
    readonly $container: PropertyValueAssertion | PropertyValueRestrictionAxiom;
    readonly $type: 'AnonymousConceptInstance';
    ownedPropertyValues: Array<PropertyValueAssertion>;
    type?: Reference<Concept>;
}

export const AnonymousConceptInstance = 'AnonymousConceptInstance';

export function isAnonymousConceptInstance(item: unknown): item is AnonymousConceptInstance {
    return reflection.isInstance(item, AnonymousConceptInstance);
}

export interface AnonymousRelationInstance extends AstNode {
    readonly $container: PropertyValueAssertion | PropertyValueRestrictionAxiom;
    readonly $type: 'AnonymousRelationInstance';
    ownedPropertyValues: Array<PropertyValueAssertion>;
    target: Reference<NamedInstance>;
}

export const AnonymousRelationInstance = 'AnonymousRelationInstance';

export function isAnonymousRelationInstance(item: unknown): item is AnonymousRelationInstance {
    return reflection.isInstance(item, AnonymousRelationInstance);
}

export interface Argument extends AstNode {
    readonly $container: BuiltInPredicate | DifferentFromPredicate | PropertyPredicate | RelationEntityPredicate | SameAsPredicate | TypePredicate;
    readonly $type: 'Argument';
    instance?: Reference<NamedInstance>;
    literal?: Literal;
    variable?: string;
}

export const Argument = 'Argument';

export function isArgument(item: unknown): item is Argument {
    return reflection.isInstance(item, Argument);
}

export interface Aspect extends AstNode {
    readonly $container: Vocabulary;
    readonly $type: 'Aspect';
    name?: string;
    ownedAnnotations: Array<Annotation>;
    ownedEquivalences: Array<EntityEquivalenceAxiom>;
    ownedKeys: Array<KeyAxiom>;
    ownedPropertyRestrictions: Array<PropertyRestrictionAxiom>;
    ownedSpecializations: Array<SpecializationAxiom>;
    ref?: Reference<Aspect>;
}

export const Aspect = 'Aspect';

export function isAspect(item: unknown): item is Aspect {
    return reflection.isInstance(item, Aspect);
}

export interface BooleanLiteral extends AstNode {
    readonly $container: Annotation | Argument | LiteralEnumerationAxiom | PropertyValueAssertion | PropertyValueRestrictionAxiom | ScalarEquivalenceAxiom;
    readonly $type: 'BooleanLiteral';
    value: Boolean;
}

export const BooleanLiteral = 'BooleanLiteral';

export function isBooleanLiteral(item: unknown): item is BooleanLiteral {
    return reflection.isInstance(item, BooleanLiteral);
}

export interface BuiltIn extends AstNode {
    readonly $container: Vocabulary;
    readonly $type: 'BuiltIn';
    name?: string;
    ownedAnnotations: Array<Annotation>;
    ref?: Reference<BuiltIn>;
}

export const BuiltIn = 'BuiltIn';

export function isBuiltIn(item: unknown): item is BuiltIn {
    return reflection.isInstance(item, BuiltIn);
}

export interface BuiltInPredicate extends AstNode {
    readonly $container: Rule;
    readonly $type: 'BuiltInPredicate';
    arguments: Array<Argument>;
    builtIn: Reference<BuiltIn>;
}

export const BuiltInPredicate = 'BuiltInPredicate';

export function isBuiltInPredicate(item: unknown): item is BuiltInPredicate {
    return reflection.isInstance(item, BuiltInPredicate);
}

export interface Concept extends AstNode {
    readonly $container: Vocabulary;
    readonly $type: 'Concept';
    name?: string;
    ownedAnnotations: Array<Annotation>;
    ownedEnumeration?: InstanceEnumerationAxiom;
    ownedEquivalences: Array<EntityEquivalenceAxiom>;
    ownedKeys: Array<KeyAxiom>;
    ownedPropertyRestrictions: Array<PropertyRestrictionAxiom>;
    ownedSpecializations: Array<SpecializationAxiom>;
    ref?: Reference<Concept>;
}

export const Concept = 'Concept';

export function isConcept(item: unknown): item is Concept {
    return reflection.isInstance(item, Concept);
}

export interface ConceptInstance extends AstNode {
    readonly $container: Description;
    readonly $type: 'ConceptInstance';
    name?: string;
    ownedAnnotations: Array<Annotation>;
    ownedPropertyValues: Array<PropertyValueAssertion>;
    ownedTypes: Array<TypeAssertion>;
    ref?: Reference<ConceptInstance>;
}

export const ConceptInstance = 'ConceptInstance';

export function isConceptInstance(item: unknown): item is ConceptInstance {
    return reflection.isInstance(item, ConceptInstance);
}

export interface DecimalLiteral extends AstNode {
    readonly $container: Annotation | Argument | LiteralEnumerationAxiom | PropertyValueAssertion | PropertyValueRestrictionAxiom | ScalarEquivalenceAxiom;
    readonly $type: 'DecimalLiteral';
    value: Decimal;
}

export const DecimalLiteral = 'DecimalLiteral';

export function isDecimalLiteral(item: unknown): item is DecimalLiteral {
    return reflection.isInstance(item, DecimalLiteral);
}

export interface Description extends AstNode {
    readonly $type: 'Description';
    namespace: string;
    ownedAnnotations: Array<Annotation>;
    ownedImports: Array<Import>;
    ownedStatements: Array<DescriptionStatement>;
    prefix: string;
}

export const Description = 'Description';

export function isDescription(item: unknown): item is Description {
    return reflection.isInstance(item, Description);
}

export interface DescriptionBundle extends AstNode {
    readonly $type: 'DescriptionBundle';
    namespace: string;
    ownedAnnotations: Array<Annotation>;
    ownedImports: Array<Import>;
    prefix: string;
}

export const DescriptionBundle = 'DescriptionBundle';

export function isDescriptionBundle(item: unknown): item is DescriptionBundle {
    return reflection.isInstance(item, DescriptionBundle);
}

export interface DifferentFromPredicate extends AstNode {
    readonly $container: Rule;
    readonly $type: 'DifferentFromPredicate';
    argument1: Argument;
    argument2: Argument;
}

export const DifferentFromPredicate = 'DifferentFromPredicate';

export function isDifferentFromPredicate(item: unknown): item is DifferentFromPredicate {
    return reflection.isInstance(item, DifferentFromPredicate);
}

export interface DoubleLiteral extends AstNode {
    readonly $container: Annotation | Argument | LiteralEnumerationAxiom | PropertyValueAssertion | PropertyValueRestrictionAxiom | ScalarEquivalenceAxiom;
    readonly $type: 'DoubleLiteral';
    value: Double;
}

export const DoubleLiteral = 'DoubleLiteral';

export function isDoubleLiteral(item: unknown): item is DoubleLiteral {
    return reflection.isInstance(item, DoubleLiteral);
}

export interface EntityEquivalenceAxiom extends AstNode {
    readonly $container: Aspect | Concept | RelationEntity;
    readonly $type: 'EntityEquivalenceAxiom';
    ownedPropertyRestrictions: Array<PropertyRestrictionAxiom>;
    superEntities: Array<Reference<Entity>>;
}

export const EntityEquivalenceAxiom = 'EntityEquivalenceAxiom';

export function isEntityEquivalenceAxiom(item: unknown): item is EntityEquivalenceAxiom {
    return reflection.isInstance(item, EntityEquivalenceAxiom);
}

export interface ForwardRelation extends AstNode {
    readonly $container: RelationEntity;
    readonly $type: 'ForwardRelation';
    name: string;
    ownedAnnotations: Array<Annotation>;
}

export const ForwardRelation = 'ForwardRelation';

export function isForwardRelation(item: unknown): item is ForwardRelation {
    return reflection.isInstance(item, ForwardRelation);
}

export interface Import extends AstNode {
    readonly $container: Description | DescriptionBundle | Vocabulary | VocabularyBundle;
    readonly $type: 'Import';
    imported: Reference<Ontology>;
    kind: 'extends' | 'includes' | 'uses' | ImportKind;
    prefix?: string;
}

export const Import = 'Import';

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import);
}

export interface InstanceEnumerationAxiom extends AstNode {
    readonly $container: Concept;
    readonly $type: 'InstanceEnumerationAxiom';
    instances: Array<Reference<ConceptInstance>>;
}

export const InstanceEnumerationAxiom = 'InstanceEnumerationAxiom';

export function isInstanceEnumerationAxiom(item: unknown): item is InstanceEnumerationAxiom {
    return reflection.isInstance(item, InstanceEnumerationAxiom);
}

export interface IntegerLiteral extends AstNode {
    readonly $container: Annotation | Argument | LiteralEnumerationAxiom | PropertyValueAssertion | PropertyValueRestrictionAxiom | ScalarEquivalenceAxiom;
    readonly $type: 'IntegerLiteral';
    value: Integer;
}

export const IntegerLiteral = 'IntegerLiteral';

export function isIntegerLiteral(item: unknown): item is IntegerLiteral {
    return reflection.isInstance(item, IntegerLiteral);
}

export interface KeyAxiom extends AstNode {
    readonly $container: Aspect | Concept | RelationEntity;
    readonly $type: 'KeyAxiom';
    properties: Array<Reference<Property>>;
}

export const KeyAxiom = 'KeyAxiom';

export function isKeyAxiom(item: unknown): item is KeyAxiom {
    return reflection.isInstance(item, KeyAxiom);
}

export interface LiteralEnumerationAxiom extends AstNode {
    readonly $container: Scalar;
    readonly $type: 'LiteralEnumerationAxiom';
    literals: Array<Literal>;
}

export const LiteralEnumerationAxiom = 'LiteralEnumerationAxiom';

export function isLiteralEnumerationAxiom(item: unknown): item is LiteralEnumerationAxiom {
    return reflection.isInstance(item, LiteralEnumerationAxiom);
}

export interface PropertyCardinalityRestrictionAxiom extends AstNode {
    readonly $container: Aspect | Concept | EntityEquivalenceAxiom | RelationEntity;
    readonly $type: 'PropertyCardinalityRestrictionAxiom';
    cardinality: UnsignedInteger;
    kind: CardinalityRestrictionKind;
    property: Reference<SemanticProperty>;
    range?: Reference<Type>;
}

export const PropertyCardinalityRestrictionAxiom = 'PropertyCardinalityRestrictionAxiom';

export function isPropertyCardinalityRestrictionAxiom(item: unknown): item is PropertyCardinalityRestrictionAxiom {
    return reflection.isInstance(item, PropertyCardinalityRestrictionAxiom);
}

export interface PropertyEquivalenceAxiom extends AstNode {
    readonly $container: AnnotationProperty | ScalarProperty | UnreifiedRelation;
    readonly $type: 'PropertyEquivalenceAxiom';
    superProperty: Reference<Property>;
}

export const PropertyEquivalenceAxiom = 'PropertyEquivalenceAxiom';

export function isPropertyEquivalenceAxiom(item: unknown): item is PropertyEquivalenceAxiom {
    return reflection.isInstance(item, PropertyEquivalenceAxiom);
}

export interface PropertyPredicate extends AstNode {
    readonly $container: Rule;
    readonly $type: 'PropertyPredicate';
    argument1: Argument;
    argument2: Argument;
    property: Reference<Property>;
}

export const PropertyPredicate = 'PropertyPredicate';

export function isPropertyPredicate(item: unknown): item is PropertyPredicate {
    return reflection.isInstance(item, PropertyPredicate);
}

export interface PropertyRangeRestrictionAxiom extends AstNode {
    readonly $container: Aspect | Concept | EntityEquivalenceAxiom | RelationEntity;
    readonly $type: 'PropertyRangeRestrictionAxiom';
    kind: RangeRestrictionKind;
    property: Reference<SemanticProperty>;
    range: Reference<Type>;
}

export const PropertyRangeRestrictionAxiom = 'PropertyRangeRestrictionAxiom';

export function isPropertyRangeRestrictionAxiom(item: unknown): item is PropertyRangeRestrictionAxiom {
    return reflection.isInstance(item, PropertyRangeRestrictionAxiom);
}

export interface PropertySelfRestrictionAxiom extends AstNode {
    readonly $container: Aspect | Concept | EntityEquivalenceAxiom | RelationEntity;
    readonly $type: 'PropertySelfRestrictionAxiom';
    property: Reference<SemanticProperty>;
}

export const PropertySelfRestrictionAxiom = 'PropertySelfRestrictionAxiom';

export function isPropertySelfRestrictionAxiom(item: unknown): item is PropertySelfRestrictionAxiom {
    return reflection.isInstance(item, PropertySelfRestrictionAxiom);
}

export interface PropertyValueAssertion extends AstNode {
    readonly $container: AnonymousConceptInstance | AnonymousRelationInstance | ConceptInstance | RelationInstance;
    readonly $type: 'PropertyValueAssertion';
    containedValues: Array<AnonymousInstance>;
    literalValues: Array<Literal>;
    property: Reference<SemanticProperty>;
    referencedValues: Array<Reference<NamedInstance>>;
}

export const PropertyValueAssertion = 'PropertyValueAssertion';

export function isPropertyValueAssertion(item: unknown): item is PropertyValueAssertion {
    return reflection.isInstance(item, PropertyValueAssertion);
}

export interface PropertyValueRestrictionAxiom extends AstNode {
    readonly $container: Aspect | Concept | EntityEquivalenceAxiom | RelationEntity;
    readonly $type: 'PropertyValueRestrictionAxiom';
    containedValue?: AnonymousInstance;
    literalValue?: Literal;
    property: Reference<SemanticProperty>;
    referencedValue?: Reference<NamedInstance>;
}

export const PropertyValueRestrictionAxiom = 'PropertyValueRestrictionAxiom';

export function isPropertyValueRestrictionAxiom(item: unknown): item is PropertyValueRestrictionAxiom {
    return reflection.isInstance(item, PropertyValueRestrictionAxiom);
}

export interface QuotedLiteral extends AstNode {
    readonly $container: Annotation | Argument | LiteralEnumerationAxiom | PropertyValueAssertion | PropertyValueRestrictionAxiom | ScalarEquivalenceAxiom;
    readonly $type: 'QuotedLiteral';
    langTag?: string;
    type?: Reference<Scalar>;
    value: string;
}

export const QuotedLiteral = 'QuotedLiteral';

export function isQuotedLiteral(item: unknown): item is QuotedLiteral {
    return reflection.isInstance(item, QuotedLiteral);
}

export interface RelationEntity extends AstNode {
    readonly $container: Vocabulary;
    readonly $type: 'RelationEntity';
    asymmetric: boolean;
    forwardRelation?: ForwardRelation;
    functional: boolean;
    inverseFunctional: boolean;
    irreflexive: boolean;
    name?: string;
    ownedAnnotations: Array<Annotation>;
    ownedEquivalences: Array<EntityEquivalenceAxiom>;
    ownedKeys: Array<KeyAxiom>;
    ownedPropertyRestrictions: Array<PropertyRestrictionAxiom>;
    ownedSpecializations: Array<SpecializationAxiom>;
    ref?: Reference<RelationEntity>;
    reflexive: boolean;
    reverseRelation?: ReverseRelation;
    sources: Array<Reference<Entity>>;
    symmetric: boolean;
    targets: Array<Reference<Entity>>;
    transitive: boolean;
}

export const RelationEntity = 'RelationEntity';

export function isRelationEntity(item: unknown): item is RelationEntity {
    return reflection.isInstance(item, RelationEntity);
}

export interface RelationEntityPredicate extends AstNode {
    readonly $container: Rule;
    readonly $type: 'RelationEntityPredicate';
    argument: Argument;
    argument1: Argument;
    argument2: Argument;
    type: Reference<RelationEntity>;
}

export const RelationEntityPredicate = 'RelationEntityPredicate';

export function isRelationEntityPredicate(item: unknown): item is RelationEntityPredicate {
    return reflection.isInstance(item, RelationEntityPredicate);
}

export interface RelationInstance extends AstNode {
    readonly $container: Description;
    readonly $type: 'RelationInstance';
    name?: string;
    ownedAnnotations: Array<Annotation>;
    ownedPropertyValues: Array<PropertyValueAssertion>;
    ownedTypes: Array<TypeAssertion>;
    ref?: Reference<RelationInstance>;
    sources: Array<Reference<NamedInstance>>;
    targets: Array<Reference<NamedInstance>>;
}

export const RelationInstance = 'RelationInstance';

export function isRelationInstance(item: unknown): item is RelationInstance {
    return reflection.isInstance(item, RelationInstance);
}

export interface ReverseRelation extends AstNode {
    readonly $container: RelationEntity | UnreifiedRelation;
    readonly $type: 'ReverseRelation';
    name: string;
    ownedAnnotations: Array<Annotation>;
}

export const ReverseRelation = 'ReverseRelation';

export function isReverseRelation(item: unknown): item is ReverseRelation {
    return reflection.isInstance(item, ReverseRelation);
}

export interface Rule extends AstNode {
    readonly $container: Vocabulary;
    readonly $type: 'Rule';
    antecedent: Array<Predicate>;
    consequent: Array<Predicate>;
    name?: string;
    ownedAnnotations: Array<Annotation>;
    ref?: Reference<Rule>;
}

export const Rule = 'Rule';

export function isRule(item: unknown): item is Rule {
    return reflection.isInstance(item, Rule);
}

export interface SameAsPredicate extends AstNode {
    readonly $container: Rule;
    readonly $type: 'SameAsPredicate';
    argument1: Argument;
    argument2: Argument;
}

export const SameAsPredicate = 'SameAsPredicate';

export function isSameAsPredicate(item: unknown): item is SameAsPredicate {
    return reflection.isInstance(item, SameAsPredicate);
}

export interface Scalar extends AstNode {
    readonly $container: Vocabulary;
    readonly $type: 'Scalar';
    name?: string;
    ownedAnnotations: Array<Annotation>;
    ownedEnumeration?: LiteralEnumerationAxiom;
    ownedEquivalences: Array<ScalarEquivalenceAxiom>;
    ownedSpecializations: Array<SpecializationAxiom>;
    ref?: Reference<Scalar>;
}

export const Scalar = 'Scalar';

export function isScalar(item: unknown): item is Scalar {
    return reflection.isInstance(item, Scalar);
}

export interface ScalarEquivalenceAxiom extends AstNode {
    readonly $container: Scalar;
    readonly $type: 'ScalarEquivalenceAxiom';
    language: Array<string>;
    length: Array<UnsignedInteger>;
    maxExclusive: Array<Literal>;
    maxInclusive: Array<Literal>;
    maxLength: Array<UnsignedInteger>;
    minExclusive: Array<Literal>;
    minInclusive: Array<Literal>;
    minLength: Array<UnsignedInteger>;
    pattern: Array<string>;
    superScalar: Reference<Scalar>;
}

export const ScalarEquivalenceAxiom = 'ScalarEquivalenceAxiom';

export function isScalarEquivalenceAxiom(item: unknown): item is ScalarEquivalenceAxiom {
    return reflection.isInstance(item, ScalarEquivalenceAxiom);
}

export interface ScalarProperty extends AstNode {
    readonly $container: Vocabulary;
    readonly $type: 'ScalarProperty';
    domains: Array<Reference<Entity>>;
    functional: boolean;
    name?: string;
    ownedAnnotations: Array<Annotation>;
    ownedEquivalences: Array<PropertyEquivalenceAxiom>;
    ownedSpecializations: Array<SpecializationAxiom>;
    ranges: Array<Reference<Scalar>>;
    ref?: Reference<ScalarProperty>;
}

export const ScalarProperty = 'ScalarProperty';

export function isScalarProperty(item: unknown): item is ScalarProperty {
    return reflection.isInstance(item, ScalarProperty);
}

export interface SpecializationAxiom extends AstNode {
    readonly $container: AnnotationProperty | Aspect | Concept | RelationEntity | Scalar | ScalarProperty | UnreifiedRelation;
    readonly $type: 'SpecializationAxiom';
    superTerm: Reference<Term>;
}

export const SpecializationAxiom = 'SpecializationAxiom';

export function isSpecializationAxiom(item: unknown): item is SpecializationAxiom {
    return reflection.isInstance(item, SpecializationAxiom);
}

export interface TypeAssertion extends AstNode {
    readonly $container: ConceptInstance | RelationInstance;
    readonly $type: 'TypeAssertion';
    type: Reference<Entity>;
}

export const TypeAssertion = 'TypeAssertion';

export function isTypeAssertion(item: unknown): item is TypeAssertion {
    return reflection.isInstance(item, TypeAssertion);
}

export interface TypePredicate extends AstNode {
    readonly $container: Rule;
    readonly $type: 'TypePredicate';
    argument: Argument;
    type: Reference<Type>;
}

export const TypePredicate = 'TypePredicate';

export function isTypePredicate(item: unknown): item is TypePredicate {
    return reflection.isInstance(item, TypePredicate);
}

export interface UnreifiedRelation extends AstNode {
    readonly $container: Vocabulary;
    readonly $type: 'UnreifiedRelation';
    asymmetric: boolean;
    functional: boolean;
    inverseFunctional: boolean;
    irreflexive: boolean;
    name?: string;
    ownedAnnotations: Array<Annotation>;
    ownedEquivalences: Array<PropertyEquivalenceAxiom>;
    ownedSpecializations: Array<SpecializationAxiom>;
    ref?: Reference<Relation>;
    reflexive: boolean;
    reverseRelation?: ReverseRelation;
    sources: Array<Reference<Entity>>;
    symmetric: boolean;
    targets: Array<Reference<Entity>>;
    transitive: boolean;
}

export const UnreifiedRelation = 'UnreifiedRelation';

export function isUnreifiedRelation(item: unknown): item is UnreifiedRelation {
    return reflection.isInstance(item, UnreifiedRelation);
}

export interface Vocabulary extends AstNode {
    readonly $type: 'Vocabulary';
    namespace: string;
    ownedAnnotations: Array<Annotation>;
    ownedImports: Array<Import>;
    ownedStatements: Array<VocabularyStatement>;
    prefix: string;
}

export const Vocabulary = 'Vocabulary';

export function isVocabulary(item: unknown): item is Vocabulary {
    return reflection.isInstance(item, Vocabulary);
}

export interface VocabularyBundle extends AstNode {
    readonly $type: 'VocabularyBundle';
    namespace: string;
    ownedAnnotations: Array<Annotation>;
    ownedImports: Array<Import>;
    prefix: string;
}

export const VocabularyBundle = 'VocabularyBundle';

export function isVocabularyBundle(item: unknown): item is VocabularyBundle {
    return reflection.isInstance(item, VocabularyBundle);
}

export type OmlAstType = {
    Annotation: Annotation
    AnnotationProperty: AnnotationProperty
    AnonymousConceptInstance: AnonymousConceptInstance
    AnonymousInstance: AnonymousInstance
    AnonymousRelationInstance: AnonymousRelationInstance
    Argument: Argument
    Aspect: Aspect
    Assertion: Assertion
    Axiom: Axiom
    BinaryPredicate: BinaryPredicate
    BooleanLiteral: BooleanLiteral
    BuiltIn: BuiltIn
    BuiltInPredicate: BuiltInPredicate
    Concept: Concept
    ConceptInstance: ConceptInstance
    DecimalLiteral: DecimalLiteral
    Description: Description
    DescriptionBox: DescriptionBox
    DescriptionBundle: DescriptionBundle
    DescriptionMember: DescriptionMember
    DescriptionStatement: DescriptionStatement
    DifferentFromPredicate: DifferentFromPredicate
    DoubleLiteral: DoubleLiteral
    Element: Element
    Entity: Entity
    EntityEquivalenceAxiom: EntityEquivalenceAxiom
    ForwardRelation: ForwardRelation
    IdentifiedElement: IdentifiedElement
    Import: Import
    Instance: Instance
    InstanceEnumerationAxiom: InstanceEnumerationAxiom
    IntegerLiteral: IntegerLiteral
    KeyAxiom: KeyAxiom
    Literal: Literal
    LiteralEnumerationAxiom: LiteralEnumerationAxiom
    Member: Member
    NamedInstance: NamedInstance
    Ontology: Ontology
    Predicate: Predicate
    Property: Property
    PropertyCardinalityRestrictionAxiom: PropertyCardinalityRestrictionAxiom
    PropertyEquivalenceAxiom: PropertyEquivalenceAxiom
    PropertyPredicate: PropertyPredicate
    PropertyRangeRestrictionAxiom: PropertyRangeRestrictionAxiom
    PropertyRestrictionAxiom: PropertyRestrictionAxiom
    PropertySelfRestrictionAxiom: PropertySelfRestrictionAxiom
    PropertyValueAssertion: PropertyValueAssertion
    PropertyValueRestrictionAxiom: PropertyValueRestrictionAxiom
    QuotedLiteral: QuotedLiteral
    Relation: Relation
    RelationBase: RelationBase
    RelationEntity: RelationEntity
    RelationEntityPredicate: RelationEntityPredicate
    RelationInstance: RelationInstance
    ReverseRelation: ReverseRelation
    Rule: Rule
    SameAsPredicate: SameAsPredicate
    Scalar: Scalar
    ScalarEquivalenceAxiom: ScalarEquivalenceAxiom
    ScalarProperty: ScalarProperty
    SemanticProperty: SemanticProperty
    SpecializableProperty: SpecializableProperty
    SpecializableTerm: SpecializableTerm
    SpecializationAxiom: SpecializationAxiom
    Statement: Statement
    Term: Term
    Type: Type
    TypeAssertion: TypeAssertion
    TypePredicate: TypePredicate
    UnaryPredicate: UnaryPredicate
    UnreifiedRelation: UnreifiedRelation
    Vocabulary: Vocabulary
    VocabularyBox: VocabularyBox
    VocabularyBundle: VocabularyBundle
    VocabularyMember: VocabularyMember
    VocabularyStatement: VocabularyStatement
}

export class OmlAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return [Annotation, AnnotationProperty, AnonymousConceptInstance, AnonymousInstance, AnonymousRelationInstance, Argument, Aspect, Assertion, Axiom, BinaryPredicate, BooleanLiteral, BuiltIn, BuiltInPredicate, Concept, ConceptInstance, DecimalLiteral, Description, DescriptionBox, DescriptionBundle, DescriptionMember, DescriptionStatement, DifferentFromPredicate, DoubleLiteral, Element, Entity, EntityEquivalenceAxiom, ForwardRelation, IdentifiedElement, Import, Instance, InstanceEnumerationAxiom, IntegerLiteral, KeyAxiom, Literal, LiteralEnumerationAxiom, Member, NamedInstance, Ontology, Predicate, Property, PropertyCardinalityRestrictionAxiom, PropertyEquivalenceAxiom, PropertyPredicate, PropertyRangeRestrictionAxiom, PropertyRestrictionAxiom, PropertySelfRestrictionAxiom, PropertyValueAssertion, PropertyValueRestrictionAxiom, QuotedLiteral, Relation, RelationBase, RelationEntity, RelationEntityPredicate, RelationInstance, ReverseRelation, Rule, SameAsPredicate, Scalar, ScalarEquivalenceAxiom, ScalarProperty, SemanticProperty, SpecializableProperty, SpecializableTerm, SpecializationAxiom, Statement, Term, Type, TypeAssertion, TypePredicate, UnaryPredicate, UnreifiedRelation, Vocabulary, VocabularyBox, VocabularyBundle, VocabularyMember, VocabularyStatement];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case Annotation:
            case Argument:
            case Assertion:
            case Axiom:
            case IdentifiedElement:
            case Import:
            case Instance:
            case Literal:
            case Predicate: {
                return this.isSubtype(Element, supertype);
            }
            case AnnotationProperty: {
                return this.isSubtype(SpecializableProperty, supertype);
            }
            case AnonymousConceptInstance:
            case AnonymousRelationInstance: {
                return this.isSubtype(AnonymousInstance, supertype);
            }
            case AnonymousInstance: {
                return this.isSubtype(Instance, supertype);
            }
            case Aspect:
            case Concept: {
                return this.isSubtype(Entity, supertype);
            }
            case BinaryPredicate:
            case BuiltInPredicate:
            case UnaryPredicate: {
                return this.isSubtype(Predicate, supertype);
            }
            case BooleanLiteral:
            case DecimalLiteral:
            case DoubleLiteral:
            case IntegerLiteral:
            case QuotedLiteral: {
                return this.isSubtype(Literal, supertype);
            }
            case BuiltIn:
            case Rule: {
                return this.isSubtype(VocabularyStatement, supertype);
            }
            case ConceptInstance:
            case RelationInstance: {
                return this.isSubtype(NamedInstance, supertype);
            }
            case Description:
            case DescriptionBundle: {
                return this.isSubtype(DescriptionBox, supertype);
            }
            case DescriptionBox:
            case VocabularyBox: {
                return this.isSubtype(Ontology, supertype);
            }
            case DescriptionMember:
            case Statement:
            case VocabularyMember: {
                return this.isSubtype(Member, supertype);
            }
            case DescriptionStatement: {
                return this.isSubtype(DescriptionMember, supertype) || this.isSubtype(Statement, supertype);
            }
            case DifferentFromPredicate:
            case PropertyPredicate:
            case SameAsPredicate: {
                return this.isSubtype(BinaryPredicate, supertype);
            }
            case Entity:
            case Scalar: {
                return this.isSubtype(Type, supertype);
            }
            case EntityEquivalenceAxiom:
            case InstanceEnumerationAxiom:
            case KeyAxiom:
            case LiteralEnumerationAxiom:
            case PropertyEquivalenceAxiom:
            case PropertyRestrictionAxiom:
            case ScalarEquivalenceAxiom:
            case SpecializationAxiom: {
                return this.isSubtype(Axiom, supertype);
            }
            case ForwardRelation:
            case ReverseRelation: {
                return this.isSubtype(Relation, supertype);
            }
            case Member:
            case Ontology: {
                return this.isSubtype(IdentifiedElement, supertype);
            }
            case NamedInstance: {
                return this.isSubtype(DescriptionStatement, supertype) || this.isSubtype(Instance, supertype);
            }
            case Property:
            case RelationBase: {
                return this.isSubtype(Term, supertype);
            }
            case PropertyCardinalityRestrictionAxiom:
            case PropertyRangeRestrictionAxiom:
            case PropertySelfRestrictionAxiom:
            case PropertyValueRestrictionAxiom: {
                return this.isSubtype(PropertyRestrictionAxiom, supertype);
            }
            case PropertyValueAssertion:
            case TypeAssertion: {
                return this.isSubtype(Assertion, supertype);
            }
            case Relation: {
                return this.isSubtype(SemanticProperty, supertype);
            }
            case RelationEntity: {
                return this.isSubtype(Entity, supertype) || this.isSubtype(RelationBase, supertype);
            }
            case RelationEntityPredicate:
            case TypePredicate: {
                return this.isSubtype(UnaryPredicate, supertype);
            }
            case ScalarProperty: {
                return this.isSubtype(SemanticProperty, supertype) || this.isSubtype(SpecializableProperty, supertype);
            }
            case SemanticProperty: {
                return this.isSubtype(Property, supertype);
            }
            case SpecializableProperty: {
                return this.isSubtype(Property, supertype) || this.isSubtype(SpecializableTerm, supertype);
            }
            case SpecializableTerm: {
                return this.isSubtype(Term, supertype) || this.isSubtype(VocabularyStatement, supertype);
            }
            case Term: {
                return this.isSubtype(VocabularyMember, supertype);
            }
            case Type: {
                return this.isSubtype(SpecializableTerm, supertype);
            }
            case UnreifiedRelation: {
                return this.isSubtype(Relation, supertype) || this.isSubtype(RelationBase, supertype) || this.isSubtype(SpecializableProperty, supertype);
            }
            case Vocabulary:
            case VocabularyBundle: {
                return this.isSubtype(VocabularyBox, supertype);
            }
            case VocabularyStatement: {
                return this.isSubtype(Statement, supertype) || this.isSubtype(VocabularyMember, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Annotation:property':
            case 'AnnotationProperty:ref': {
                return AnnotationProperty;
            }
            case 'Annotation:referencedValues': {
                return Member;
            }
            case 'AnonymousConceptInstance:type':
            case 'Concept:ref': {
                return Concept;
            }
            case 'AnonymousRelationInstance:target':
            case 'Argument:instance':
            case 'PropertyValueAssertion:referencedValues':
            case 'PropertyValueRestrictionAxiom:referencedValue':
            case 'RelationInstance:sources':
            case 'RelationInstance:targets': {
                return NamedInstance;
            }
            case 'Aspect:ref': {
                return Aspect;
            }
            case 'BuiltIn:ref':
            case 'BuiltInPredicate:builtIn': {
                return BuiltIn;
            }
            case 'ConceptInstance:ref':
            case 'InstanceEnumerationAxiom:instances': {
                return ConceptInstance;
            }
            case 'EntityEquivalenceAxiom:superEntities':
            case 'RelationEntity:sources':
            case 'RelationEntity:targets':
            case 'ScalarProperty:domains':
            case 'TypeAssertion:type':
            case 'UnreifiedRelation:sources':
            case 'UnreifiedRelation:targets': {
                return Entity;
            }
            case 'Import:imported': {
                return Ontology;
            }
            case 'KeyAxiom:properties':
            case 'PropertyEquivalenceAxiom:superProperty':
            case 'PropertyPredicate:property': {
                return Property;
            }
            case 'PropertyCardinalityRestrictionAxiom:property':
            case 'PropertyRangeRestrictionAxiom:property':
            case 'PropertySelfRestrictionAxiom:property':
            case 'PropertyValueAssertion:property':
            case 'PropertyValueRestrictionAxiom:property': {
                return SemanticProperty;
            }
            case 'PropertyCardinalityRestrictionAxiom:range':
            case 'PropertyRangeRestrictionAxiom:range':
            case 'TypePredicate:type': {
                return Type;
            }
            case 'QuotedLiteral:type':
            case 'Scalar:ref':
            case 'ScalarEquivalenceAxiom:superScalar':
            case 'ScalarProperty:ranges': {
                return Scalar;
            }
            case 'RelationEntity:ref':
            case 'RelationEntityPredicate:type': {
                return RelationEntity;
            }
            case 'RelationInstance:ref': {
                return RelationInstance;
            }
            case 'Rule:ref': {
                return Rule;
            }
            case 'ScalarProperty:ref': {
                return ScalarProperty;
            }
            case 'SpecializationAxiom:superTerm': {
                return Term;
            }
            case 'UnreifiedRelation:ref': {
                return Relation;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case Annotation: {
                return {
                    name: Annotation,
                    properties: [
                        { name: 'literalValues', defaultValue: [] },
                        { name: 'property' },
                        { name: 'referencedValues', defaultValue: [] }
                    ]
                };
            }
            case AnnotationProperty: {
                return {
                    name: AnnotationProperty,
                    properties: [
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedEquivalences', defaultValue: [] },
                        { name: 'ownedSpecializations', defaultValue: [] },
                        { name: 'ref' }
                    ]
                };
            }
            case AnonymousConceptInstance: {
                return {
                    name: AnonymousConceptInstance,
                    properties: [
                        { name: 'ownedPropertyValues', defaultValue: [] },
                        { name: 'type' }
                    ]
                };
            }
            case AnonymousRelationInstance: {
                return {
                    name: AnonymousRelationInstance,
                    properties: [
                        { name: 'ownedPropertyValues', defaultValue: [] },
                        { name: 'target' }
                    ]
                };
            }
            case Argument: {
                return {
                    name: Argument,
                    properties: [
                        { name: 'instance' },
                        { name: 'literal' },
                        { name: 'variable' }
                    ]
                };
            }
            case Aspect: {
                return {
                    name: Aspect,
                    properties: [
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedEquivalences', defaultValue: [] },
                        { name: 'ownedKeys', defaultValue: [] },
                        { name: 'ownedPropertyRestrictions', defaultValue: [] },
                        { name: 'ownedSpecializations', defaultValue: [] },
                        { name: 'ref' }
                    ]
                };
            }
            case BooleanLiteral: {
                return {
                    name: BooleanLiteral,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case BuiltIn: {
                return {
                    name: BuiltIn,
                    properties: [
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ref' }
                    ]
                };
            }
            case BuiltInPredicate: {
                return {
                    name: BuiltInPredicate,
                    properties: [
                        { name: 'arguments', defaultValue: [] },
                        { name: 'builtIn' }
                    ]
                };
            }
            case Concept: {
                return {
                    name: Concept,
                    properties: [
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedEnumeration' },
                        { name: 'ownedEquivalences', defaultValue: [] },
                        { name: 'ownedKeys', defaultValue: [] },
                        { name: 'ownedPropertyRestrictions', defaultValue: [] },
                        { name: 'ownedSpecializations', defaultValue: [] },
                        { name: 'ref' }
                    ]
                };
            }
            case ConceptInstance: {
                return {
                    name: ConceptInstance,
                    properties: [
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedPropertyValues', defaultValue: [] },
                        { name: 'ownedTypes', defaultValue: [] },
                        { name: 'ref' }
                    ]
                };
            }
            case DecimalLiteral: {
                return {
                    name: DecimalLiteral,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case Description: {
                return {
                    name: Description,
                    properties: [
                        { name: 'namespace' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedImports', defaultValue: [] },
                        { name: 'ownedStatements', defaultValue: [] },
                        { name: 'prefix' }
                    ]
                };
            }
            case DescriptionBundle: {
                return {
                    name: DescriptionBundle,
                    properties: [
                        { name: 'namespace' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedImports', defaultValue: [] },
                        { name: 'prefix' }
                    ]
                };
            }
            case DifferentFromPredicate: {
                return {
                    name: DifferentFromPredicate,
                    properties: [
                        { name: 'argument1' },
                        { name: 'argument2' }
                    ]
                };
            }
            case DoubleLiteral: {
                return {
                    name: DoubleLiteral,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case EntityEquivalenceAxiom: {
                return {
                    name: EntityEquivalenceAxiom,
                    properties: [
                        { name: 'ownedPropertyRestrictions', defaultValue: [] },
                        { name: 'superEntities', defaultValue: [] }
                    ]
                };
            }
            case ForwardRelation: {
                return {
                    name: ForwardRelation,
                    properties: [
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] }
                    ]
                };
            }
            case Import: {
                return {
                    name: Import,
                    properties: [
                        { name: 'imported' },
                        { name: 'kind' },
                        { name: 'prefix' }
                    ]
                };
            }
            case InstanceEnumerationAxiom: {
                return {
                    name: InstanceEnumerationAxiom,
                    properties: [
                        { name: 'instances', defaultValue: [] }
                    ]
                };
            }
            case IntegerLiteral: {
                return {
                    name: IntegerLiteral,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case KeyAxiom: {
                return {
                    name: KeyAxiom,
                    properties: [
                        { name: 'properties', defaultValue: [] }
                    ]
                };
            }
            case LiteralEnumerationAxiom: {
                return {
                    name: LiteralEnumerationAxiom,
                    properties: [
                        { name: 'literals', defaultValue: [] }
                    ]
                };
            }
            case PropertyCardinalityRestrictionAxiom: {
                return {
                    name: PropertyCardinalityRestrictionAxiom,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'kind' },
                        { name: 'property' },
                        { name: 'range' }
                    ]
                };
            }
            case PropertyEquivalenceAxiom: {
                return {
                    name: PropertyEquivalenceAxiom,
                    properties: [
                        { name: 'superProperty' }
                    ]
                };
            }
            case PropertyPredicate: {
                return {
                    name: PropertyPredicate,
                    properties: [
                        { name: 'argument1' },
                        { name: 'argument2' },
                        { name: 'property' }
                    ]
                };
            }
            case PropertyRangeRestrictionAxiom: {
                return {
                    name: PropertyRangeRestrictionAxiom,
                    properties: [
                        { name: 'kind' },
                        { name: 'property' },
                        { name: 'range' }
                    ]
                };
            }
            case PropertySelfRestrictionAxiom: {
                return {
                    name: PropertySelfRestrictionAxiom,
                    properties: [
                        { name: 'property' }
                    ]
                };
            }
            case PropertyValueAssertion: {
                return {
                    name: PropertyValueAssertion,
                    properties: [
                        { name: 'containedValues', defaultValue: [] },
                        { name: 'literalValues', defaultValue: [] },
                        { name: 'property' },
                        { name: 'referencedValues', defaultValue: [] }
                    ]
                };
            }
            case PropertyValueRestrictionAxiom: {
                return {
                    name: PropertyValueRestrictionAxiom,
                    properties: [
                        { name: 'containedValue' },
                        { name: 'literalValue' },
                        { name: 'property' },
                        { name: 'referencedValue' }
                    ]
                };
            }
            case QuotedLiteral: {
                return {
                    name: QuotedLiteral,
                    properties: [
                        { name: 'langTag' },
                        { name: 'type' },
                        { name: 'value' }
                    ]
                };
            }
            case RelationEntity: {
                return {
                    name: RelationEntity,
                    properties: [
                        { name: 'asymmetric', defaultValue: false },
                        { name: 'forwardRelation' },
                        { name: 'functional', defaultValue: false },
                        { name: 'inverseFunctional', defaultValue: false },
                        { name: 'irreflexive', defaultValue: false },
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedEquivalences', defaultValue: [] },
                        { name: 'ownedKeys', defaultValue: [] },
                        { name: 'ownedPropertyRestrictions', defaultValue: [] },
                        { name: 'ownedSpecializations', defaultValue: [] },
                        { name: 'ref' },
                        { name: 'reflexive', defaultValue: false },
                        { name: 'reverseRelation' },
                        { name: 'sources', defaultValue: [] },
                        { name: 'symmetric', defaultValue: false },
                        { name: 'targets', defaultValue: [] },
                        { name: 'transitive', defaultValue: false }
                    ]
                };
            }
            case RelationEntityPredicate: {
                return {
                    name: RelationEntityPredicate,
                    properties: [
                        { name: 'argument' },
                        { name: 'argument1' },
                        { name: 'argument2' },
                        { name: 'type' }
                    ]
                };
            }
            case RelationInstance: {
                return {
                    name: RelationInstance,
                    properties: [
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedPropertyValues', defaultValue: [] },
                        { name: 'ownedTypes', defaultValue: [] },
                        { name: 'ref' },
                        { name: 'sources', defaultValue: [] },
                        { name: 'targets', defaultValue: [] }
                    ]
                };
            }
            case ReverseRelation: {
                return {
                    name: ReverseRelation,
                    properties: [
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] }
                    ]
                };
            }
            case Rule: {
                return {
                    name: Rule,
                    properties: [
                        { name: 'antecedent', defaultValue: [] },
                        { name: 'consequent', defaultValue: [] },
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ref' }
                    ]
                };
            }
            case SameAsPredicate: {
                return {
                    name: SameAsPredicate,
                    properties: [
                        { name: 'argument1' },
                        { name: 'argument2' }
                    ]
                };
            }
            case Scalar: {
                return {
                    name: Scalar,
                    properties: [
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedEnumeration' },
                        { name: 'ownedEquivalences', defaultValue: [] },
                        { name: 'ownedSpecializations', defaultValue: [] },
                        { name: 'ref' }
                    ]
                };
            }
            case ScalarEquivalenceAxiom: {
                return {
                    name: ScalarEquivalenceAxiom,
                    properties: [
                        { name: 'language', defaultValue: [] },
                        { name: 'length', defaultValue: [] },
                        { name: 'maxExclusive', defaultValue: [] },
                        { name: 'maxInclusive', defaultValue: [] },
                        { name: 'maxLength', defaultValue: [] },
                        { name: 'minExclusive', defaultValue: [] },
                        { name: 'minInclusive', defaultValue: [] },
                        { name: 'minLength', defaultValue: [] },
                        { name: 'pattern', defaultValue: [] },
                        { name: 'superScalar' }
                    ]
                };
            }
            case ScalarProperty: {
                return {
                    name: ScalarProperty,
                    properties: [
                        { name: 'domains', defaultValue: [] },
                        { name: 'functional', defaultValue: false },
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedEquivalences', defaultValue: [] },
                        { name: 'ownedSpecializations', defaultValue: [] },
                        { name: 'ranges', defaultValue: [] },
                        { name: 'ref' }
                    ]
                };
            }
            case SpecializationAxiom: {
                return {
                    name: SpecializationAxiom,
                    properties: [
                        { name: 'superTerm' }
                    ]
                };
            }
            case TypeAssertion: {
                return {
                    name: TypeAssertion,
                    properties: [
                        { name: 'type' }
                    ]
                };
            }
            case TypePredicate: {
                return {
                    name: TypePredicate,
                    properties: [
                        { name: 'argument' },
                        { name: 'type' }
                    ]
                };
            }
            case UnreifiedRelation: {
                return {
                    name: UnreifiedRelation,
                    properties: [
                        { name: 'asymmetric', defaultValue: false },
                        { name: 'functional', defaultValue: false },
                        { name: 'inverseFunctional', defaultValue: false },
                        { name: 'irreflexive', defaultValue: false },
                        { name: 'name' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedEquivalences', defaultValue: [] },
                        { name: 'ownedSpecializations', defaultValue: [] },
                        { name: 'ref' },
                        { name: 'reflexive', defaultValue: false },
                        { name: 'reverseRelation' },
                        { name: 'sources', defaultValue: [] },
                        { name: 'symmetric', defaultValue: false },
                        { name: 'targets', defaultValue: [] },
                        { name: 'transitive', defaultValue: false }
                    ]
                };
            }
            case Vocabulary: {
                return {
                    name: Vocabulary,
                    properties: [
                        { name: 'namespace' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedImports', defaultValue: [] },
                        { name: 'ownedStatements', defaultValue: [] },
                        { name: 'prefix' }
                    ]
                };
            }
            case VocabularyBundle: {
                return {
                    name: VocabularyBundle,
                    properties: [
                        { name: 'namespace' },
                        { name: 'ownedAnnotations', defaultValue: [] },
                        { name: 'ownedImports', defaultValue: [] },
                        { name: 'prefix' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    properties: []
                };
            }
        }
    }
}

export const reflection = new OmlAstReflection();
